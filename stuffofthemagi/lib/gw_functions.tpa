/* ================================================================================================================================================== *
 * LIST of FUNCTIONS :                                                                                                                                *
 * -------------------                                                                                                                                *
 *  - FUNCTION GW_UPDATE_ITM_DESCRIPTION_TO_EE      : MODIFIES item descriptions to fit EE description format.                         => line #  13  *
 *  - FUNCTION GW_WRITE_EE_ITM_DESCRIPTIONS         : WRITES item descriptions in ITM files according to the game (classical or EE).   => line #  52  *
 *  - MACRO GW_ADJUST_TOOLTIP                       : ADDS new columns in tooltip.2da file if needed.                                  => line # 102  *
 *  - MACRO GW_READ_COL_TOOLTIP                     : READS tooltip.2da file number of columns.                                        => line # 136  *
 *  - FUNCTION GW_ADD_ITEM_TOOLTIPS                 : ADDS a new line in tooltip.2da. file.                                            => line # 151  *
 *  - FUNCTION GW_ALTER_ITEM_ALTER_HEADER_FLAGS     : ALTERS itm extender headers new EE (or ToBEx) flags.                             => line # 196  *
 * ================================================================================================================================================== */

/* ========================================================================================================== *
 * FUNCTION GW_UPDATE_ITM_DESCRIPTION_TO_EE: AJUSTE la DESCRIPTION des OBJETS au format Enhanced Edition.     *
 * ---------------------------------------------------------------------------------------------------------- *
 * Reads variable GW_desc_to_update (@nn or #nnn) in .tra file, alters it to fit EE description format,       *
 * then saves it as variable GW_desc_updated.                                                                 *
 * ========================================================================================================== *
 * FUNCTION GW_WRITE_EE_ITM_DESCRIPTIONS: ÉCRIT les DESCRIPTIONS des OBJETS au format Enhanced Edition.       *
 * ---------------------------------------------------------------------------------------------------------- *
 * Reads variables GW_desc_to_update and GW_undesc_to_update (@nnn or #nnn) in .tra file, alters them to fit  *
 * EE description format if needed, then updates .ITM file.                                                   *
 * ========================================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_UPDATE_ITM_DESCRIPTION_TO_EE~ 
	STR_VAR GW_desc_to_update = ~~	// reference in format @123 or #123
	RET		GW_desc_updated			// returns modified text
BEGIN

	INNER_ACTION BEGIN
		ACTION_IF (~%GW_desc_to_update%~ STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ == 0) BEGIN
			<<<<<<<< .../inlined/GW_%GW_desc_to_update%.tpp
OUTER_SPRINT GW_desc_updated 
>>>>>>>>
			SILENT
			COPY - ~.../inlined/GW_%GW_desc_to_update%.tpp~ ~.../inlined/GW_%GW_desc_to_update%.tpp~
				INSERT_BYTES SOURCE_SIZE (STRING_LENGTH ~%GW_desc_to_update%~)
				WRITE_ASCIIE SOURCE_SIZE ~%GW_desc_to_update%~
			INCLUDE ~.../inlined/GW_%GW_desc_to_update%.tpp~
			OUTER_SPRINT usab @9001		// ~[Uu]niquement[ %tab%]+[Uu]tilisable[ %tab%]+[Pp]ar[ %tab%]*:~ = ~[Oo]nly[ %tab%]+[Uu]sable[ %tab%]+[Bb]y[ %tab%]*:~
			OUTER_SPRINT unus @9002		// ~\([Nn]on[ %tab%]+\|[Ii]n\)[Uu]tilisable[ %tab%]+[Pp]ar[ %tab%]*:~ = ~\(Not[ %tab%]+\|Un\)[Uu]sable[ %tab%]+[Bb]y[ %tab%]*:~
			OUTER_PATCH_SAVE GW_desc_updated ~%GW_desc_updated%~ BEGIN	// Suppression de toutes les références aux classes et aux kits pouvant ou pas utiliser l'objet. - Removes all classes and kits (un-)usability flags.
				REPLACE_TEXTUALLY ~\(\([%LNL%%MNL%%WNL%][ %TAB%]*\(%usab%\|%unus%\)[ %TAB%]*\)\(\([%LNL%%MNL%%WNL%].*\)*\)?\)~  ~~
			END
		END ELSE BEGIN
			OUTER_SPRINT GW_desc_updated ~none~
		END
	END	// of INNER_ACTION

END		// of DEFINE_PATCH_FUNCTION


DEFINE_PATCH_FUNCTION ~GW_WRITE_EE_ITM_DESCRIPTIONS~ 
	STR_VAR GW_desc_to_update	= ~~	// reference in format @123 or #123
			GW_undesc_to_update = ~~	// reference in format @123 or #123
BEGIN

	PATCH_IF (is_ee) BEGIN	// EE games

		SPRINT GWdesc "none"
		SPRINT GWundesc "none"
		PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_desc_to_update%" STR_CMP ~~) BEGIN
			LPF ~GW_UPDATE_ITM_DESCRIPTION_TO_EE~ STR_VAR GW_desc_to_update = EVAL "%GW_desc_to_update%" RET GWdesc = GW_desc_updated END
		END ELSE BEGIN
			SPRINT GWdesc ~none~
		END
		PATCH_IF ("%GW_undesc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_undesc_to_update%" STR_CMP ~~) BEGIN
			LPF ~GW_UPDATE_ITM_DESCRIPTION_TO_EE~ STR_VAR GW_desc_to_update = EVAL "%GW_undesc_to_update%" RET GWundesc = GW_desc_updated END
		END ELSE BEGIN
			SPRINT GWundesc ~none~
		END
		PATCH_IF ("%GWdesc%" STR_CMP "none")	BEGIN SAY_EVALUATED DESC ~%GWdesc%~ END
		PATCH_IF ("%GWundesc%" STR_CMP "none")	BEGIN SAY_EVALUATED UNIDENTIFIED_DESC ~%GWundesc%~ END 

	END ELSE BEGIN			// classical games
		PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_desc_to_update%" STR_CMP ~~) BEGIN
			INNER_PATCH_SAVE GWdesc ~%GW_desc_to_update%~ BEGIN		// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
				REPLACE_TEXTUALLY ~^[@#]~  ~~
			END
			PATCH_IF ("%GW_desc_to_update%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
				WRITE_LONG 0x54 RESOLVE_STR_REF ((AT %GWdesc%))
			END ELSE BEGIN
				WRITE_LONG 0x54 %GWdesc%
			END
		END
		PATCH_IF ("%GW_undesc_to_update%" STRING_COMPARE_REGEXP ~^[@#]-?[0-9]+$~ = 0) AND ("%GW_undesc_to_update%" STR_CMP ~~) BEGIN
			INNER_PATCH_SAVE GWundesc ~%GW_undesc_to_update%~ BEGIN	// Suppression du premier caractère (@ ou #) - Removes 1st character (@ or #).
				REPLACE_TEXTUALLY ~^[@#]~  ~~
			END
			PATCH_IF ("%GW_undesc_to_update%" STRING_COMPARE_REGEXP ~^[@]-?[0-9]+$~ = 0) BEGIN
				WRITE_LONG 0x50 RESOLVE_STR_REF ((AT %GWundesc%))
			END ELSE BEGIN
				WRITE_LONG 0x50 %GWundesc%
			END
		END

	END	// of PATCH_IF (is_ee)

END		// of DEFINE_PATCH_FUNCTION


/* ============================================================================= *
 * MACRO GW_ADJUST_COL_TOOLTIP: ADDS new columns in tooltip.2da file if needed.  *
 * ----------------------------------------------------------------------------- *
 * CODE borrowed and adapted from Miloch's one.                                  *
 * ============================================================================= */

DEFINE_ACTION_MACRO ~GW_ADJUST_COL_TOOLTIP~ BEGIN

	COPY_EXISTING ~tooltip.2da~ ~override~
		COUNT_2DA_COLS cl
		COUNT_2DA_ROWS 1 rw
		SPRINT cz ~~
		SPRINT rx ~       ~ // 7
		SPRINT ry ~-1~
		SPRINT rz ~~
		PATCH_IF cl < 4 BEGIN
			SPRINT rz ~$ $ 3~
			FOR (i = 0 ; i < (rw - 3) ; ++i) BEGIN	// Cycle through rows
				SPRINT rz ~%rz%~ ^ ~%rx%~ ^ ~%ry%~
			END
		END ELSE BEGIN
			FOR (j = 3 ; j < (cl - 1) ; ++j) BEGIN	// Cycle through columns
				SPRINT cz ~%cz%~ ^ ~%rx%~ ^ ~%ry%~
			END
		END
	BUT_ONLY

	ACTION_IF cl < 4 BEGIN
		APPEND_COL ~tooltip.2da~ ~%rz%~
	END

END	// of DEFINE_ACTION_MACRO


/* ====================================================================== *
 *  MACRO GW_READ_COL_TOOLTIP: READS tooltip.2da file number of columns.  *
 * ---------------------------------------------------------------------- *
 *  RETURNS cols_tooltip value (used by GW_ADD_ITEM_TOOLTIPS function).   *
 * ====================================================================== */

DEFINE_ACTION_MACRO ~GW_READ_COL_TOOLTIP~ BEGIN

	COPY_EXISTING - ~tooltip.2da~ ~override~
		COUNT_2DA_COLS cols_tooltip
		COUNT_2DA_ROWS 1 rows_tooltip

END


/* ======================================================================= *
 *  FUNCTION GW_ADD_ITEM_TOOLTIPS: ADDS a new line in tooltip.2da. file.   *
 * ----------------------------------------------------------------------- *
 *  PARSES %GW_tooltips% string chain and adds a new line in tooltip.2da.  *
 * ======================================================================= */

DEFINE_ACTION_FUNCTION ~GW_ADD_ITEM_TOOLTIPS~
	STR_VAR	GW_objet	= ~N~	// item code: ~sw1h01~
			GW_tooltips	= ~~	// tooltips stringref list: ~@123 @124 6620~, accepts combination of tra refs and strrefs for as many abilities as you need to specify
BEGIN

	ACTION_IF ("%GW_objet%" STRING_COMPARE_CASE "N") BEGIN
		ACTION_TO_UPPER GW_objet

	// Generates a new row to be added to tooltip.2da
		OUTER_TEXT_SPRINT new_row ~%GW_objet%~
		OUTER_PATCH ~ %GW_tooltips%~ BEGIN	// Extracts each tooltip from GW_tooltips string
			COUNT_REGEXP_INSTANCES ~[ %TAB%]+\(@?-?[0-9]+\)~ num_tooltips
			REPLACE_EVALUATE ~[ %TAB%]+\(@?-?[0-9]+\)~ BEGIN
				PATCH_IF ((~%MATCH1%~ STRING_MATCHES_REGEXP ~@-?[0-9]+~) = 0) BEGIN // tra ref
					INNER_PATCH_SAVE GW_tooltip ~%MATCH1%~ BEGIN
						REPLACE_TEXTUALLY ~[@]~  ~~
					END
					SET GW_tool = RESOLVE_STR_REF ( (AT GW_tooltip) )
					TEXT_SPRINT new_row ~%new_row% %GW_tool%~ 	// Adds to the new row
				END ELSE BEGIN // strref
					TEXT_SPRINT new_row ~%new_row% %MATCH1%~ 	// Adds to the new row
				END
				TEXT_SPRINT empty_cols ~~
			END ~~
		END

		ACTION_IF num_tooltips < (cols_tooltip -1) BEGIN
			OUTER_FOR (i = (cols_tooltip - 1) ; i > num_tooltips ; --i) BEGIN	// Generates -1 entries for the number of missing columns
				OUTER_TEXT_SPRINT empty_cols ~%empty_cols% -1~
			END
		END

		OUTER_TEXT_SPRINT new_row ~%new_row%%empty_cols%~
		APPEND ~tooltip.2da~ ~%new_row%~ UNLESS ~^%GW_objet%~

	END

END	// of DEFINE_ACTION_FUNCTION


/* ====================================================================================================================================== *
 *  FUNCTION GW_ALTER_ITEM_ALTER_HEADER_FLAGS: ALTERS itm extender headers new EE (or ToBEx) flags.                                       *
 * -------------------------------------------------------------------------------------------------------------------------------------- *
 *  INTEGER VARIABLES :                                                                                                                   *
 *    - type                : header type (1 = Melee - 2 = Range - 3 = Magical - 4) Launcher - default = "-1", all).                      *
 *    - header              : modifies specified header (default = 0, matches all headers, used with type = -1).                          *
 *    - flag_strength       : adds strength bonus, set in bit0  (1 = adds - 0 = remove - default = "-1", no change).                      *
 *    - flag_break          : breakable, set in bit1 (1 = adds - 0 = remove - default = "-1", no change).                                 *
 *    - flag_breaksanctuary : breaks sanctuary (EE), set in bit9 (1 = adds - 0 = remove - default = "-1", no change).                     *
 *    - flag_hostile        : hostile, set in bit10 (1 = adds - 0 = remove - default = "-1", no change).                                  *
 *    - flag_recharge       : recharge after resting, set in bit11   (1 = adds - 0 = remove - default = "-1", no change).                 *
 *    - flag_bypass         : bypass armor, set in bit16 (1 = adds - 0 = remove - default = "-1", no change).                             *
 *    - flag_keenedge       : keen edge, set in bit17 (1 = adds - 0 = remove - default = "-1", no change).                                *
 *    - flag_backstab       : can backstab (EE and ToBEx), set in bit25  (1 = adds - 0 = remove - default = "-1", no change).             *
 *    - flag_noinvisible    : cannot target invisible (EE and ToBEx), set in bit26  (1 = adds - 0 = remove - default = "-1", no change).  *
 * ====================================================================================================================================== */

DEFINE_PATCH_FUNCTION ~GW_ALTER_ITEM_ALTER_HEADER_FLAGS~
	INT_VAR type				= "-1" // -1 is all headers, otherwise use value here
			header				= 0    // 0 matches all headers, otherwise just modify specified header - use with type = -1
			// flag_vars affect flags starting at 0x26; 0 means removes flag, 1 means adds flag, -1 no change
			flag_strength		= "-1" // adds strength bonus, bit0
			flag_break			= "-1" // breakable, bit1
//			flag_str_damage		= "-1" // damage damage bonus, ee, bit2
//			flag_str_to_hit		= "-1" // thac0 strength bonus, ee, bit3
			flag_breaksanctuary	= "-1" // breaks sanctuary, ee, bit9
			flag_hostile		= "-1" // hostile, bit10
			flag_recharge		= "-1" // recharge after resting, bit11
			flag_bypass			= "-1" // bypass armor, bit16
			flag_keenedge		= "-1" // keen edge, bit17
			flag_backstab		= "-1" // tobex and ee only, can backstab, bit25
			flag_noinvisible	= "-1" // tobex and ee only, cannot target invisible, bit26
BEGIN

	READ_LONG  0x64 "abil_off"
	READ_SHORT 0x68 "abil_num"
//PATCH_PRINT "DEBUGGING CONTROL abil_off = %abil_off% - abil_num = %abil_num%"
	PATCH_IF (header = 0) BEGIN
		SET loop_start = 0
		SET loop_end = abil_num
	END ELSE BEGIN
		SET loop_start = (header - 1)
		SET loop_end = header
	END
//PATCH_PRINT "DEBUGGING CONTROL loop_start = %loop_start% - loop_end = %loop_end%"

	FOR (i = loop_start ; i < loop_end ; ++i) BEGIN
		SET offset = abil_off + (i * 0x38)
		READ_BYTE offset abil_type
		PATCH_IF ((type < 0) OR (abil_type = type)) BEGIN
			READ_LONG (offset + 0x26) flags
			SET flags_off = (offset + 0x26)
//PATCH_PRINT "DEBUGGING CONTROL i = %i% ==> offset = %offset% - abil_type = %abil_type% - flags_off = %flags_off% - flags = %flags%"
			PATCH_IF (flag_strength = 0) AND ((flags & BIT0) = BIT0) BEGIN
				WRITE_LONG flags_off (THIS & `BIT0)
			END
			PATCH_IF (flag_strength = 1) AND ((flags & BIT0) = 0) BEGIN	// (THIS BOR BIT0)
				WRITE_LONG flags_off (THIS | BIT0)
			END
			PATCH_IF (flag_break = 0) AND ((flags & BIT1) = BIT1) BEGIN
				WRITE_LONG flags_off (THIS & `BIT1)
			END
			PATCH_IF (flag_break = 1) AND ((flags & BIT1) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT1)
			END
/*			PATCH_IF (flag_str_damage  = 0) AND ((flags & BIT2) = BIT2) BEGIN
				WRITE_LONG (flags_off) THIS & `BIT2)
			END
			PATCH_IF (flag_str_damage  = 1) AND ((flags & BIT2) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT2)
			END
			PATCH_IF (flag_str_to_hit = 0) AND ((flags & BIT3) = BIT3) BEGIN
				WRITE_LONG flags_off (THIS & `BIT3)
			END
			PATCH_IF (flag_str_to_hit = 1) AND ((flags & BIT3) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT3)
			END
*/			PATCH_IF (flag_breaksanctuary = 0) AND ((flags & BIT9) = BIT9) BEGIN
				WRITE_LONG flags_off (THIS & `BIT9)
			END
			PATCH_IF (flag_breaksanctuary = 1) AND ((flags & BIT9) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT9)
			END
			PATCH_IF (flag_hostile = 0) AND ((flags & BIT10) = BIT10) BEGIN
				WRITE_LONG flags_off (THIS & `BIT10)
			END
			PATCH_IF (flag_hostile = 1) AND ((flags & BIT10) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT10)
			END
			PATCH_IF (flag_recharge = 0) AND ((flags & BIT11) = BIT11) BEGIN
				WRITE_LONG flags_off (THIS & `BIT11)
			END
			PATCH_IF (flag_recharge = 1) AND ((flags & BIT11) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT11)
			END
			PATCH_IF (flag_bypass = 0) AND ((flags & BIT16) = BIT16) BEGIN
				WRITE_LONG flags_off (THIS & `BIT16)
			END
			PATCH_IF (flag_bypass = 1) AND ((flags & BIT16) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT16)
			END
			PATCH_IF (flag_keenedge = 0) AND ((flags & BIT17) = BIT17) BEGIN
				WRITE_LONG flags_off (THIS & `BIT17)
			END
			PATCH_IF (flag_keenedge = 1) AND ((flags & BIT17) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT17)
			END
			PATCH_IF (flag_backstab = 0) AND ((flags & BIT25) = BIT25) BEGIN
				WRITE_LONG flags_off (THIS & `BIT25)
			END
			PATCH_IF (flag_backstab = 1) AND ((flags & BIT25) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT25)
			END
			PATCH_IF (flag_noinvisible = 0) AND ((flags & BIT26) = BIT26) BEGIN
				WRITE_LONG flags_off (THIS & `BIT26)
			END
			PATCH_IF (flag_noinvisible = 1) AND ((flags & BIT26) = 0) BEGIN
				WRITE_LONG flags_off (THIS | BIT26)
			END
		END

	END

END	// of DEFINE_ACTION_FUNCTION
